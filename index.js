'use strict';
const http = require('http');
const https = require('https');
const base64js = require('base64-js');
const FormData = require('form-data');
const fs = require('fs');

/**
 * @param httpOptions
 *  {
 *    hostname: string,   // Required.
 *    sn: stirng,         // Required.
 *    key: stirng,        // Required.
 * 
 *    ip: string,         // Generated by module.
 *    port: number,       // Generated by module.
 *    https: boolean      // Generated by module.
 *  }
 * @param params
 *  {
 *    before: number,     // Optional. Unix timestamp.
 *    after: number,      // Optional. Unix timestamp.
 *    pageSize: number,   // Optional.
 *    pageIndex: number,  // Optional.
 *  }
 */
function list(httpOptions, params) {
  const httpParamErr = checkHttpOptions(httpOptions);
  if (httpParamErr) {
    return Promise.reject(new Error(httpParamErr));
  }

  // Check parameters.
  if (params.before !== undefined && (typeof params.before !== 'number')) {
    return Promise.reject(new Error('"before" should be valid unix timestamp.'));
  } else if (params.after !== undefined && (typeof params.after !== 'number')) {
    return Promise.reject(new Error('"after" should be valid unix timestamp.'));
  } else if (params.pageSize !== undefined && (typeof params.pageSize !== 'number')) {
    return Promise.reject(new Error('"pageSize" should be valid number.'));
  } else if (params.pageIndex !== undefined && (typeof params.pageIndex !== 'number')) {
    return Promise.reject(new Error('"pageIndex" should be valid number.'));
  }

  // Build query string.
  let qs = '';
  if (params.before !== undefined)
    qs += ('&before=' + params.before);
  if (params.after !== undefined)
    qs += ('&after=' + params.after);
  if (params.pageSize !== undefined)
    qs += ('&page_size=' + params.pageSize);
  if (params.pageIndex !== undefined)
    qs += ('&page_index=' + params.pageIndex);
  if (qs)
    qs = '?' + qs.substr(1);

  // Send request and get response.
  return new Promise((resolve, reject) => {
    let resultData = "";
    let request = (httpOptions.https ? https : http).request(
      buildTrafficOptions(httpOptions, '/file/list' + qs, 'GET'),
      function (response) {
        response.setEncoding('utf8');
        response.on('data', function (chunk) { resultData += chunk; });
        response.on('end', function () {
          if (!resultData) {
            reject(new Error('Server returns nothing.'));
            return;
          }
          if (resultData.indexOf("{") !== 0 && resultData.indexOf("[") !== 0) {
            reject(new Error('Server returns error. ' + resultData));
            return;
          }
          try {
            let resultObj = JSON.parse(resultData);
            if (!resultObj || !resultObj.verbose_msg) {
              reject(new Error('Server error.'));
            } else if (resultObj.verbose_msg !== 'success') {
              reject(new Error(resultObj.verbose_msg));
            } else {
              resolve(resultObj);
            }
          } catch (ex) { reject(new Error('Server returns error. ' + resultData)); }
        });
      }
    );
    request.on('error', function (ex) {
      reject(ex);
    });
    request.end();
  });
}

/**
 * @param params
 *  {
 *    resource: string,   // Required. md5/sha1/sha256/scan_id
 *    allInfo: boolean    // Optional. If return additional information about the file. Default is false.
 *  }
 */
function report(httpOptions, params) {
  const httpParamErr = checkHttpOptions(httpOptions);
  if (httpParamErr) {
    return Promise.reject(new Error(httpParamErr));
  }

  // Check parameters.
  if (!params.resource || (typeof params.resource !== 'string') || !params.resource.trim()) {
    return Promise.reject(new Error('"resource" as string is required.'));
  } else if (params.allInfo !== undefined && (typeof params.allInfo !== 'boolean')) {
    return Promise.reject(new Error('"allInfo" should be boolean.'));
  }

  // Build query string.
  let qs = '?resource=' + params.resource + '&all_info=' + (params.allInfo !== undefined ? params.allInfo.toString() : 'false');

  // Send request and get response.
  return new Promise((resolve, reject) => {
    let resultData = "";
    let request = (httpOptions.https ? https : http).request(
      buildTrafficOptions(httpOptions, '/file/report' + qs, 'GET'),
      function (response) {
        response.setEncoding('utf8');
        response.on('data', function (chunk) { resultData += chunk; });
        response.on('end', function () {
          if (!resultData) {
            reject(new Error('Server returns nothing.'));
            return;
          }
          if (resultData.indexOf("{") !== 0 && resultData.indexOf("[") !== 0) {
            reject(new Error('Server returns error. ' + resultData));
            return;
          }
          try {
            let resultObj = JSON.parse(resultData);
            if (!resultObj || !resultObj.verbose_msg) {
              reject(new Error('Server error.'));
            } else if (resultObj.verbose_msg !== 'success') {
              reject(new Error(resultObj.verbose_msg));
            } else {
              resolve(resultObj);
            }
          } catch (ex) { reject(new Error('Server returns error. ' + resultData)); }
        });
      }
    );
    request.on('error', function (ex) {
      reject(ex);
    });
    request.end();
  });
}

/**
 * @param sha256 // Required.
 */
function artifact(httpOptions, sha256) {
  const httpParamErr = checkHttpOptions(httpOptions);
  if (httpParamErr) {
    return Promise.reject(new Error(httpParamErr));
  }

  // Check parameters.
  if (!sha256 || (typeof sha256 !== 'string') || !sha256.trim()) {
    return Promise.reject(new Error('"sha256" as string is required.'));
  }

  // Build query string.
  let qs = '?sha256=' + sha256;

  // Send request and get response.
  return new Promise((resolve, reject) => {
    let resultData = "";
    let request = (httpOptions.https ? https : http).request(
      buildTrafficOptions(httpOptions, '/file/artifact' + qs, 'GET'),
      function (response) {
        response.setEncoding('utf8');
        response.on('data', function (chunk) { resultData += chunk; });
        response.on('end', function () {
          if (!resultData) {
            reject(new Error('Server returns nothing.'));
            return;
          }
          if (resultData.indexOf("{") !== 0 && resultData.indexOf("[") !== 0) {
            reject(new Error('Server returns error. ' + resultData));
            return;
          }
          try {
            let resultObj = JSON.parse(resultData);
            if (!resultObj || !resultObj.verbose_msg) {
              reject(new Error('Server error.'));
            } else if (resultObj.verbose_msg !== 'success') {
              reject(new Error(resultObj.verbose_msg));
            } else {
              resolve(resultObj);
            }
          } catch (ex) { reject(new Error('Server returns error. ' + resultData)); }
        });
      }
    );
    request.on('error', function (ex) {
      reject(ex);
    });
    request.end();
  });
}

/**
 * @param filePath // Required.
 */
function scan(httpOptions, filePath) {
  const httpParamErr = checkHttpOptions(httpOptions);
  if (httpParamErr) {
    return Promise.reject(new Error(httpParamErr));
  }

  // Check parameters.
  if (!filePath || (typeof filePath !== 'string') || !filePath.trim()) {
    return Promise.reject(new Error('"filePath" as string is required.'));
  }

  // Send request and get response.
  const form = new FormData();
  form.append('file', fs.createReadStream(filePath));
  return new Promise((resolve, reject) => {
    let resultData = "";

    form.getLength((err, length) => {
      if (err) {
        reject(err);
        return;
      }
      const traffOpt = {
        hostname: httpOptions.ip,
        port: httpOptions.port === undefined ? (httpOptions.https ? 443 : 80) : httpOptions.port,
        path: '/external/v1/file/scan',
        method: 'POST',
        headers: form.getHeaders({
          'authorization': 'Basic ' + base64js.fromByteArray(toBytes(httpOptions.sn + ':' + httpOptions.key)),
          'Content-Length': length
        })
      };
      if (httpOptions.https) {
        traffOpt.rejectUnauthorized = false;
      }
  
      const request = (httpOptions.https ? https : http).request(
        traffOpt,
        response => {
        response.on('data', function (chunk) { resultData += chunk; });
        response.on('end', function () {
          if (!resultData) {
            reject(new Error('Server returns nothing.'));
            return;
          }
          if (resultData.indexOf("{") !== 0 && resultData.indexOf("[") !== 0) {
            reject(new Error('Server returns error. ' + resultData));
            return;
          }
          try {
            let resultObj = JSON.parse(resultData);
            if (!resultObj || !resultObj.verbose_msg) {
              reject(new Error('Server error.'));
            } else if (resultObj.verbose_msg !== 'success') {
              reject(new Error(resultObj.verbose_msg));
            } else {
              resolve(resultObj);
            }
          } catch (ex) { reject(new Error('Server returns error. ' + resultData)); }
        });
      });
      form.pipe(request);
      /* FIXME: Remove this so that 'end' event handler will execute even though error occurs.
      request.on('response', function(res) {
        if (res.statusCode !== 200)
          reject('Server error. Status: ' + res.statusCode);
      }); */
      request.on('error', function (ex) {
        reject(ex);
      });
    });
  });
}

/**
 * @param params
 *  {
 *    sha256: string,    // Required.
 *    engine: string,    // Required.
 *    env: string,       // Required.
 *    type: string,      // Required. report/pcap/screenshots
 *    filePath: string   // Required.
 *  }
 */
function download(httpOptions, params) {
  const httpParamErr = checkHttpOptions(httpOptions);
  if (httpParamErr) {
    return Promise.reject(new Error(httpParamErr));
  }

  // Check parameters.
  if (!params.sha256 || (typeof params.sha256 !== 'string') || !params.sha256.trim()) {
    return Promise.reject(new Error('"sha256" as string is required.'));
  } else if (!params.engine || (typeof params.engine !== 'string') || !params.engine.trim()) {
    return Promise.reject(new Error('"engine" as string is required.'));
  } else if (!params.env || (typeof params.env !== 'string') || !params.env.trim()) {
    return Promise.reject(new Error('"env" as string is required.'));
  } else if (!params.type || (typeof params.type !== 'string') || !params.type.trim()) {
    return Promise.reject(new Error('"type" as string is required.'));
  } else if (!params.filePath || (typeof params.filePath !== 'string') || !params.filePath.trim()) {
    return Promise.reject(new Error('"filePath" as string is required.'));
  } else if (params.type !== 'report' && params.type !== 'pcap' && params.type !== 'screenshots') {
    return Promise.reject(new Error('"type" must be "report", "pcap" or "screenshots".'));
  }

  // Build query string.
  let qs = '?sha256=' + params.sha256
    + '&engine=' + params.engine
    + '&env=' + params.env
    + '&type=' + params.type;

  // Send request and get response.
  return new Promise((resolve, reject) => {
    let resultData = '';
    let request = (httpOptions.https ? https : http).request(
      buildTrafficOptions(httpOptions, '/file/download' + qs, 'GET'),
      function (response) {
        response.setEncoding('binary');
        response.on('data', function (chunk) { resultData += chunk; });
        response.on('end', function () {
          try {
            if (resultData && resultData.indexOf('verbose_msg') > 0 && resultData.indexOf('verbose_msg') < 4) { // Error.
              resolve((typeof resultData) === 'object' ? resultData : JSON.parse(resultData));
            } else if (resultData) {
              fs.writeFileSync(
                params.filePath + '/' + params.sha256 + '-' + params.engine + '-' + params.env + '-' + params.type + '.'
                  + (params.type === 'report' ? 'xml' : (params.type === 'pcap' ? 'pcap' : 'zip')),
                resultData,
                'binary'
              );
              resolve({ verbose_msg: 'success' });
            } else { reject(new Error('Server error.')); }
          } catch (ex) { reject(ex); }
        });
      }
    );
    request.on('error', function (ex) {
      reject(ex);
    });
    request.end();
  });
}


/****************************************************************************
 * 
 * The followings are help methods.
 * 
 ****************************************************************************/

// Check http parameters, and generate 'ip', 'port' and 'https' fields.
function checkHttpOptions(options) {
  if (!options || (typeof options !== "object")) {
    return 'The first parameter as options object is required.';
  } else if (!options.hostname || (typeof options.hostname !== 'string') || !options.hostname.trim()) {
    return '"hostname" as string is required.';
  } else if (!options.sn || (typeof options.sn !== 'string') || !options.sn.trim()) {
    return '"sn" as string is required.';
  } else if (!options.key || (typeof options.key !== 'string') || !options.key.trim()) {
    return '"key" as string is required.';
  }

  // Check hostname format.
  var reg = /((^https:\/\/)|(^http:\/\/)|(^))[a-zA-Z0-9_.-\/]+(($)|(:[0-9]{1,5}$)|(:[0-9]{1,5}[a-zA-Z0-9_.-\/]+$))/i;
  if (!reg.test(options.hostname)) {
    return '"hostname" is invalid.';
  }

  // Generate 'https'.
  options.https = options.hostname.indexOf('https') >= 0 ? true : false;

  // Generate 'port'.
  var idx = -1;
  if (options.hostname.indexOf('https://') >= 0) {
    idx = options.hostname.indexOf(':', 8);
  } else if (options.hostname.indexOf('http://') >= 0) {
    idx = options.hostname.indexOf(':', 7);
  } else {
    idx = options.hostname.indexOf(':');
  }
  if (idx < 0) {
    // Nothing.
  } else { // Port exists.
    var idx2 = options.hostname.indexOf('/', idx);
    if (idx2 > 0) {
      options.port = options.hostname.substring(idx + 1, idx2);
    } else {
      options.port = options.hostname.substr(idx + 1);
    }
  }

  // Generate 'ip'.
  var ipIdx = 0;
  if (options.hostname.indexOf('https://') >= 0) {
    ipIdx = 8;
  } else if (options.hostname.indexOf('http://') >= 0) {
    ipIdx = 7;
  }
  if (options.hostname.indexOf(':', ipIdx) >= 0) {
    options.ip = options.hostname.substring(ipIdx, options.hostname.indexOf(':', ipIdx));
  } else if (options.hostname.indexOf('/', ipIdx) >= 0) {
    options.ip = options.hostname.substring(ipIdx, options.hostname.indexOf('/', ipIdx));
  } else {
    options.ip = options.hostname.substr(ipIdx);
  }
}

// Build option object for http(s) request method.
function buildTrafficOptions(httpOptions, path, verb) {
  let trafficOptions = {
    hostname: httpOptions.ip,
    port: httpOptions.port === undefined ? (httpOptions.https ? 443 : 80) : httpOptions.port,
    path: '/external/v1' + path,
    method: verb,
    headers: {
      'authorization': 'Basic ' + base64js.fromByteArray(toBytes(httpOptions.sn + ':' + httpOptions.key))
    }
  };
  if (httpOptions.https) {
    trafficOptions.rejectUnauthorized = false;
  }
  return trafficOptions;
}

// String to bytes.
function toBytes(str) {
  var ch, st, re = [];
  for (var i = 0; i < str.length; i++) {
    ch = str.charCodeAt(i);
    st = [];
    do {
      st.push( ch & 0xFF );
      ch = ch >> 8;
    }  
    while (ch);
    re = re.concat( st.reverse() );
  }
  return re;
}

exports.list = list;
exports.report = report;
exports.artifact = artifact;
exports.scan = scan;
exports.download = download;
